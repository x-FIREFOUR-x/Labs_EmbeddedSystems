#include <avr/io.h>
#include <avr/interrupt.h>

#define TRUE 1
#define FALSE 0

  // Режими роботи годинника.
#define MODE_WORK 0
#define MODE_EDIT_SECS 1
#define MODE_EDIT_MINS 2
#define MODE_EDIT_HOURS 3

  // Ліміти для годин, хвилин і секунд у BCD-коді
#define LIMIT_HOURS 0x24
#define LIMIT_MINUTES 0x60
#define LIMIT_SECONDS 0x60

  // Позиції у масиві, де зберігаються відповідні компоненти поточного часу
#define I_SECONDS 0
#define I_MINUTES 1
#define I_HOURS 2

  // Кількість цифр на індикаторі
#define N_DIGITS 6

  // * Частота процесора * UL - беззнаковий Long [0, +4 294 967 295]
#define F_CPU (4000000UL)

/* кількість зсувів праворуч для переміщення старшої тетради у молодшу */
#define HI_NIBBLE_SHIFT 0x04
/* Маска для виділення молодшої тетради */
#define LO_NIBBLE_MASK 0x0F // 0b00001111 == 0x0F
/* Константа для виконання корекції BCD-числа при досягенні межі 0xXA*/
#define BCD_CORRECTION 0x06
/* Маска для виділення стану вивода, до якого підключено кнопку +1*/
#define PLUS_BUTTON_MASK 0x40
/* Затримка для утримання кнопки +1 перед початком автоінкременту*/
#define AUTOINC_DELAY 2
/* Маска для ініціалізації порту E */
#define PE_INIT_MASK 0x3F // 0b00111111 == 0x3F
/*
* Маска для гасіння індикатора, враховано два старших біта,
* біти що використовуються для включения резисторів, що підтягують, на входах PE6
і PE7
*/
#define INDICATOR_DESELECT_MASK 0xC0 // 0b11000000 == 0xC0
/* Частота оновлення індикатора у Гц. */
#define REFRESH_RATE 100
/* Коефіціент передподільника Т/С1. */
#define PRESCALER 64
/* Сегменти індикатора. */
#define A 1    // 0b00000001 == 0x01
#define B 2    // 0b00000010 == 0x02
#define C 4    // 0b00000100 == 0x04
#define D 8    // 0b00001000 == 0x08
#define E 16   // 0b00010000 == 0x10
#define F 32   // 0b00100000 == 0x20
#define G 64   // 0b01000000 == 0x40
#define DP 128 // 0b10000000 == 0x80
/* Таблиця перекодування у "семисегментний" код. */
const unsigned char LED_CODE[] = {
    // 1.3
    A | B | C | D | E | F, // 0x3F -> '0'
    B | C,                 // 0x06 -> '1'
    A | B | D | E | G,     // 0x5B -> '2'
    A | B | C | D | G,     // 0x4F -> '3'
    B | C | F | G,         // 0x66 -> '4'
    A | C | D | F | G,     // 0x6D -> '5'

    A |
        C | D | E | F | G,     // 0x7D -> '6'
    A | B | C,                 // 0x07 -> '7'
    A | B | C | D | E | F | G, // 0x7F -> '8'
    A | B | C | D | F | G      // 0x6F -> '9'
};
/* Граничне значення T/C1, за якого індикатор (повністю) оновлюється:
REFRESH_RATE разів у секунду. */
const unsigned int TIMER_MAX = F_CPU / PRESCALER / REFRESH_RATE /
                               N_DIGITS;
/*
 * Число оновлень індикатора, посля якого відбувається оновлення маски
 * миготіння, простіше – період миготіння.
 */
const unsigned int BLINK_MAX = 150;
/* Лічильник оновлень. */
unsigned char updateCounter = 0; // 1.4
/* Маска миготіння. */
unsigned char blinkMask = 0xFF;
/* Нова маска миготіння. */
unsigned char newBlinkMask = 0xFF;
/* Масив для зберігання поточного часу у BCD-коді. */
unsigned char time[3] = {
    0, // секунди
    0, // хвилини
    0  // години
};
/* Остання оновлена цифра. */
unsigned char lastRefreshedDigit = 0;
/* Режим. */
unsigned char mode = MODE_EDIT_HOURS;
/* Лічильник утримання кнопки. */
unsigned char holdCounter = 0;
/*
 * Функція інкремента заданого значения у масиві.
 * index – індекс у масиві часу
 * limit – максимальне значення (у BCD-коді).
 * Повертає TRUE, якщо у поточній позиції відбулося переповнення, яке може
 * означати, що необхідно оновити також інші позиції.
 */

unsigned char incTimePosition(unsigned char index, unsigned char limit) // 2.2.2.0
{                                                                       // 5.2.1.0
  if (index < N_DIGITS >> 1)
  {                // 2.2.2.1; 5.2.1.1
    time[index]++; // 2.2.2.2; 5.2.1.2
    /*
     * Лічба відбувається в BCD-коді. Якщо досягли значення 0xXA, то необхідно
     * додати 0x06, щоб отримати 0xY0, де Y == X + 1.
     */
    if ((time[index] & LO_NIBBLE_MASK) == 0x0A)
    { // 2.2.2.3; 5.2.1.3
      /* Наприклад, 0x39 + 0x01 = 0x3A, а потрібно 0x40, тому
       * 0x3A + 0x06 = 0x40.
       */
      time[index] += BCD_CORRECTION; // 2.2.2.4; 5.2.1.4
    }
    /* У випадку досягнення граничного значення лічби -> почати з 0. */
    if (time[index] == limit)
    {                  // 2.2.2.5; 5.2.1.5
      time[index] = 0; // 2.2.2.6; 5.2.1.6
      return TRUE;
    }
  }
  return FALSE; // 2.2.2.7; 5.2.1.7
}
/*
 * Оновлює цифри на індикаторі.
 */
void refreshDigit() // 4.1.0
{
  /* lastRefreshedDigit / 2 -> індекс у масиві time[]. */
  unsigned char index = lastRefreshedDigit >> 1; // 4.1.1
  /* Старша чи молодша тетрада?
  * Якщо старша тетрада, то виконати зсув на 4 біта праворуч,
  * щоб правильно виконати виведення у порт Е.
  * За допомогою конструкції (lastRefreshedDigit & 0x01) виконується перевірка на
  парність.
  */
  unsigned char shift = (lastRefreshedDigit & 0x01) ? HI_NIBBLE_SHIFT : 0x00; // 4.1.2
  /* Визначаємо, чи потрібна крапка (у крайній правій позиції – не потрібна). */
  unsigned char point = (shift == 0 && index > 0) ? DP : 0x00; // 4.1.3
  /* Гасимо індикатор. */
  PORTE &= INDICATOR_DESELECT_MASK; // 4.1.4
  /* Виведення чергової цифри в порт D. */
  PORTD = LED_CODE[(time[index] >> shift) & LO_NIBBLE_MASK] | point; // 4.1.5

  /* Вибір позиції на індикаторі з урахуванням маски миготіння. */
  PORTE |= (1 << lastRefreshedDigit) & blinkMask; // 4.1.6
  /* Після оновлення останньої цифри -> почати з початку. */
  if (++lastRefreshedDigit == N_DIGITS)
  { // 4.1.7
    /*
     * Оновлення маски миготіння на останній цифрі, інакше можливе
     * несинхронне миготіння цифр, коли одну із них
     * ще не видно, а інша використовує нову маску і її видно,
     * та навпаки.
     */
    blinkMask = newBlinkMask; // 4.1.8
    lastRefreshedDigit = 0;   // 4.1.9
  }
} // 4.1.10
/*
 * Функція інкременту значення годин.
 */
void incHours() // 5.2.3.3.0
{
  incTimePosition(I_HOURS, LIMIT_HOURS); // 5.2.3.3.1
}
/*
 * Функція інкременту значення хвилин.
 */
void incMinutes() // 5.2.3.0
{
  /* Переповнено значенння хвилин інкремент годин. */
  if (incTimePosition(I_MINUTES, LIMIT_MINUTES))
  { // 5.2.3.1
    // 5.2.3.2
    incHours(); // 5.2.3.3
  }
} // 5.2.3.4
/*
 * Функція інкременту значення секунд.
 */
void incSeconds() // 5.2.0
{                 /* Переповнено значенння секунд інкремент хвилин. */
  if (incTimePosition(I_SECONDS, LIMIT_SECONDS))
  {               // 5.2.1 - 5.2.2
    incMinutes(); // 5.2.3
  }
}
/*
 * Функція інкременту показань годин у режимі налаштування.
 */

void setupIncTime() // 2.2.0
{
  if (mode == MODE_EDIT_HOURS)
  {                                        // 2.2.1
    incTimePosition(I_HOURS, LIMIT_HOURS); // 2.2.2
  }
  else if (mode == MODE_EDIT_MINS)
  {                                            // 2.2.3
    incTimePosition(I_MINUTES, LIMIT_MINUTES); // 2.2.4
  }
  else
  {
    incTimePosition(I_SECONDS, LIMIT_SECONDS); // 2.2.5
  }
} // 2.2.6
/*
 * Обробник переривань від асинхронного таймера T/C0.
 */
ISR(TIMER0_OVF_vect) // 5.0
{
  if (!mode)
  { // 5.1
    /* Якщо не у режимі налаштування інкрементувати час. */
    incSeconds(); // 5.2
  }
} // 5.3
/*
 * Обробник переривань від Т/C1.
 */
ISR(TIMER1_COMPA_vect) // 4.0
{
  /* Оновити цифру на індикаторі. */
  refreshDigit(); // 4.1
  if (mode == 0)
  { // 4.2
    /* Якщо в рабочому режимі більше нічого не робити. */
    return;
  }
  /* Інкремент лічильника оновлень */
  updateCounter++; // 4.3
  if (updateCounter == BLINK_MAX)
  { // 4.4
    /*
     * Якщо лічильник оновлень досяг значенння BLINK_MAX ->
     * оновити маску видимості.
     */
    /* Кнопку "+" натиснуто? */
    if (PINE & PLUS_BUTTON_MASK)
    { // 4.5
      /* Не натиснуто. */
      /*
       * Інвертувати 2 розряди у масці => 00110000b – години,
       * 00001100b – хвилини, 00000011b – секунди.
       */

      newBlinkMask ^= ((3 << ((mode - 1) << 1))); // 4.6
      /* Скинути лічильник утримання кнопки "+1". */
      holdCounter = 0; // 4.7
    }
    else
    {
      /* Натиснуто. */
      /*
       * Якщо кнопка "+1" утримується 4 періоди миготіння 
       * почати інкремент часу.
       */
      if (holdCounter == AUTOINC_DELAY)
      {                 // 4.8
        setupIncTime(); // 4.9
      }
      else
      {
        holdCounter++; // 4.10
      }
      /* У режимі автоінкременту відключити миготіння. */
      newBlinkMask = 0xFF; // 4.11
    }
    /* Скидання лічильника оновлень. */
    updateCounter = 0; // 4.12
  }
} // 4.13


/* Ініціалізація асинхронного таймера */
void initAsyncTimer() // 1.5.1.3.0; 3.7.0
{
  /* Заборона переривань від T/C0. */
  TIMSK &= ~((1 << TOIE0) | (1 << OCIE0)); // 1.5.1.3.1; 3.7.1
  /* Дозволити асинхронний режим. */
  ASSR |= (1 << AS0); // 1.5.1.3.2; 3.7.2
  /* Почати лічбу з нуля. */
  TCNT0 = 0x00; // 1.5.1.3.3; 3.7.3
  /* Встановити коефіціент дільника частоти 128. */
  TCCR0 |= (1 << CS00) | (1 << CS02); // 1.5.1.3.4; 3.7.4
  /* Очікування оновлення регістрів. */
  while (ASSR & 0x07)
    ; // 1.5.1.3.5; 3.7.5
  /* Дозволити переривання після переповнення T/C0. */
  TIMSK |= (1 << TOIE0); // 1.5.1.3.6; 3.7.6
} // 1.5.1.3.7; 3.7.7

/*
 * Обробник переривань від кнопки "Setup".
 */
ISR(INT7_vect) // 3.0
{
  if (mode == MODE_WORK)
  { // 3.1
    /* Перейти до налаштування значення годин. */
    mode = MODE_EDIT_HOURS; // 3.2
  }
  else
  {
    /* Перейти до налаштування хвилин або секунд. */
    mode--; // 3.3
  }
  /*
   * Скинути маску миготіння, щоб минулий налаштований розряд не
   * залишився невидимим.
   */
  newBlinkMask = 0xFF; // 3.4
  /* Обнулити лічильник миготіння. */
  updateCounter = 0x00; // 3.5
  /*
  * Після завершення налаштування реініціалізуємо таймер,
  * щоб перша секунда була повною, інакше можливий варіант,
  * коли після виходу із режиму налаштування значення секунд
  * інкрементується одразу.

  */
  if (mode == MODE_WORK) // 3.6
  {
    initAsyncTimer(); // 3.7
  }
} // 3.8

/*
 * Обробник переривань від кнопки "+1".
 */
ISR(INT6_vect) // 2.0
{
  if (mode == MODE_WORK)
  { // 2.1
    /* Якщо у робочому режимі нічого не робити. */
    return;
  }
  /* Інкрементувати показання у поточній позиції. */
  setupIncTime(); // 2.2
  /* Не блимаємо. */
  newBlinkMask = 0xFF; // 2.3
  /* Якщо кнопку натиснуто обнулити лічильник миготіння. */
  updateCounter = 0x00; // 2.4
} // 2.5

/* Налаштування портів введення/виведення */
void initPorts() // 1.5.1.2.0
{
  /* Налаштування порту D на виведення. */
  DDRD = 0xFF; // 1.5.1.2.1
  PORTD = 0xFF;
  /* Налаштування порту Е: PE0...PE5 – на виведення, PE6, PE7 – на введення. */
  DDRE = PE_INIT_MASK; // 1.5.1.2.2
  PORTE = 0xFF;
} // 1.5.1.2.3

/* Налаштування зовнішніх переривань для кнопок */
void initExternalInt() // 1.5.1.4.0
{
  /* Кнопки пов'язано з перериваннями INT6 та INT7. */
  EIMSK |= (1 << INT7) | (1 << INT6); // 1.5.1.4.1
  /* Переривання за фронтом. */
  EICRB |= (1 << ISC71) | (1 << ISC70) | (1 << ISC61) | (1 << ISC60); // 1.5.1.4.2
} // 1.5.1.4.3

/* Налаштування T/C1 */
void initTimer1() // 1.5.1.5.0
{
  /* WGM11, WGM10 <- 0: режим скидання лічильника T/C1 при співпадінні //1.5.1.5.1
  /* WGM13 <- 0, WGM12 <- 1, CS <- 3: джерело опорної частоти == CLKio/64. */
  TCCR1B |= 0x0B; // 1.5.1.5.2
  /* Почати лічбу з нуля. */
  TCNT1 = 0x00; // 1.5.1.5.3
  /* Граничне значення лічби таймера. */
  OCR1A = TIMER_MAX; // 1.5.1.5.4
  /* Дозволити переривання для каналу порівняння А T/C1. */
  TIMSK |= (1 << OCIE1A); // 1.5.1.5.5
} // 1.5.1.5.6

/* Ініціалізація периферії */
void init() // 1.5.1.0
{
  /* Вимкнути Watchdog (можливо не знадобиться). */
  WDTCR = 0x10; // 1.5.1.1
  /* Налаштування портів ВВ/BИB. */
  initPorts(); // 1.5.1.2
  /* Переведення T/C0 в асинхронний режим. */
  initAsyncTimer(); // 1.5.1.3
  /* Налаштування зовнішніх переривань для кнопок. */
  initExternalInt(); // 1.5.1.4
  /* Налаштування T/C1. */
  initTimer1(); // 1.5.1.5
}

/* Головна програма*/
int main() // 1.5.0
{
  /* Ініціалізація периферії */
  init(); // 1.5.1
  /* Дозволити глобальні переривання. */
  sei(); // 1.5.2
  /* Нескінченний цикл, доки не виникає одне з чотирьох переривань. */
  while (1); // 1.5.3
  return 0;
}